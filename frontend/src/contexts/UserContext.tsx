/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
 * ãƒ­ã‚°ã‚¤ãƒ³ä¸­ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚²ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’ç®¡ç†
 */

import { createContext, useContext, useEffect, useState, ReactNode, useCallback } from 'react';
import { useAuth } from './AuthContext';
import { userService } from '../services/user';
import { habitService } from '../services/habit';
import { achievementService } from '../services/achievement';
import { seedService } from '../services/seed';
import type { User, Habit, HabitRecord, Achievement, UserAchievement, Job, UserJob, Gender } from '../types';

interface UserContextType {
  // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿
  userData: User | null;
  habits: Habit[];
  habitRecords: Map<string, HabitRecord[]>;
  achievements: Achievement[];
  userAchievements: UserAchievement[];
  jobs: Job[];
  userJobs: UserJob[];
  
  // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹
  isLoading: boolean;
  
  // ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«è¨­å®šãŒå¿…è¦ã‹ã©ã†ã‹
  needsProfileSetup: boolean;
  
  // ãƒ‡ãƒ¼ã‚¿æ“ä½œé–¢æ•°
  refreshUserData: () => Promise<void>;
  refreshHabits: () => Promise<void>;
  createHabit: (habit: Partial<Habit>) => Promise<Habit | null>;
  updateHabit: (habitId: string, updates: Partial<Habit>) => Promise<Habit | null>;
  deleteHabit: (habitId: string) => Promise<boolean>;
  completeHabit: (habitId: string, date?: string, note?: string) => Promise<HabitRecord | null>;
  getHabitRecordsForDate: (habitId: string, date: string) => HabitRecord | undefined;
  isHabitCompletedToday: (habitId: string) => boolean;
  // è·æ¥­é¸æŠ
  selectJob: (jobId: string) => Promise<boolean>;
  // æ€§åˆ¥å¤‰æ›´
  changeGender: (gender: Gender) => Promise<boolean>;
}

const UserContext = createContext<UserContextType | undefined>(undefined);

export function UserProvider({ children }: { children: ReactNode }) {
  const { user, isAuthenticated } = useAuth();
  
  const [userData, setUserData] = useState<User | null>(null);
  const [habits, setHabits] = useState<Habit[]>([]);
  const [habitRecords, setHabitRecords] = useState<Map<string, HabitRecord[]>>(new Map());
  const [achievements, setAchievements] = useState<Achievement[]>([]);
  const [userAchievements, setUserAchievements] = useState<UserAchievement[]>([]);
  const [jobs, setJobs] = useState<Job[]>([]);
  const [userJobs, setUserJobs] = useState<UserJob[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [needsProfileSetup, setNeedsProfileSetup] = useState(false);

  // ä»Šæ—¥ã®æ—¥ä»˜ã‚’YYYY-MM-DDå½¢å¼ã§å–å¾—
  const getTodayDate = () => {
    const now = new Date();
    return now.toISOString().split('T')[0];
  };

  // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã¾ãŸã¯ä½œæˆ
  const refreshUserData = useCallback(async () => {
    if (!user) {
      setUserData(null);
      setNeedsProfileSetup(false);
      return;
    }

    try {
      const userId = user.userId;
      const existingUser = await userService.getUser(userId);

      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå­˜åœ¨ã—ãªã„å ´åˆã€ã¾ãŸã¯displayNameãŒè‡ªå‹•ç”Ÿæˆã•ã‚ŒãŸã¾ã¾ã®å ´åˆã¯ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«è¨­å®šãŒå¿…è¦
      if (!existingUser) {
        setUserData(null);
        setNeedsProfileSetup(true);
        return;
      }

      // displayNameãŒãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã®@ã‚ˆã‚Šå‰ã®éƒ¨åˆ†ã¨åŒã˜å ´åˆã¯ã€è‡ªå‹•ç”Ÿæˆã•ã‚ŒãŸã¨ã¿ãªã—ã¦ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«è¨­å®šã‚’ä¿ƒã™
      // ãŸã ã—ã€SSOä»¥å¤–ã®é€šå¸¸ã‚µã‚¤ãƒ³ã‚¢ãƒƒãƒ—ã®å ´åˆã¯é™¤å¤–
      const email = existingUser.email || '';
      const defaultDisplayName = email.split('@')[0];
      const isAutoGenerated = existingUser.displayName === defaultDisplayName && 
                              !existingUser.displayName.includes(' ');
      
      // Google SSOã®å ´åˆã®ã¿ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«è¨­å®šã‚’ä¿ƒã™ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ˜ç¤ºçš„ã«displayNameã‚’è¨­å®šã—ã¦ã„ãªã„å ´åˆï¼‰
      // ãŸã ã—ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ—¢ã«ç¿’æ…£ã‚’ä½œæˆã—ã¦ã„ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
      setUserData(existingUser);
      setNeedsProfileSetup(false);
    } catch (error) {
      console.error('Failed to fetch/create user data:', error);
      setNeedsProfileSetup(false);
    }
  }, [user]);

  // ç¿’æ…£ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
  const refreshHabits = useCallback(async () => {
    if (!user) {
      setHabits([]);
      return;
    }

    try {
      const userId = user.userId;
      const userHabits = await habitService.getHabits(userId);
      setHabits(userHabits.filter(h => !h.isArchived && h.isActive));

      // å„ç¿’æ…£ã®è¨˜éŒ²ã‚‚å–å¾—
      const recordsMap = new Map<string, HabitRecord[]>();
      for (const habit of userHabits) {
        const records = await habitService.getHabitRecords(habit.habitId);
        recordsMap.set(habit.habitId, records);
      }
      setHabitRecords(recordsMap);
    } catch (error) {
      console.error('Failed to fetch habits:', error);
    }
  }, [user]);

  // ã‚¢ãƒãƒ¼ãƒ–ãƒ¡ãƒ³ãƒˆã¨ã‚¸ãƒ§ãƒ–ã‚’å–å¾—
  const refreshAchievementsAndJobs = useCallback(async () => {
    if (!user) {
      setAchievements([]);
      setUserAchievements([]);
      setJobs([]);
      setUserJobs([]);
      return;
    }

    try {
      const userId = user.userId;
      console.log('ğŸ“¥ Fetching achievements and jobs for user:', userId);
      
      // ã‚·ãƒ¼ãƒ‰æ¸ˆã¿ãƒã‚§ãƒƒã‚¯ï¼ˆLocalStorageãƒ•ãƒ©ã‚°ï¼‰
      const seedCompleted = seedService.isSeedCompleted();
      
      if (!seedCompleted) {
        // ã¾ãšãƒã‚¹ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿ã®å­˜åœ¨ã‚’ç´ æ—©ããƒã‚§ãƒƒã‚¯
        console.log('ğŸ” Checking master data existence...');
        const { hasAchievements, hasJobs } = await seedService.checkMasterDataExists();
        
        if (!hasAchievements || !hasJobs) {
          console.log('ğŸŒ± Seeding master data (achievements:', hasAchievements, ', jobs:', hasJobs, ')...');
          const result = await seedService.seedAll();
          console.log('ğŸŒ± Seed result:', result);
        } else {
          console.log('âœ… Master data already exists, marking as seeded');
        }
        
        // ã‚·ãƒ¼ãƒ‰å®Œäº†ã‚’ãƒãƒ¼ã‚¯
        seedService.markSeedCompleted();
      } else {
        console.log('â­ï¸ Seed already completed, skipping');
      }
      
      // ä¸¦è¡Œã—ã¦ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
      const [allAchievements, userAch, allJobs, userJ] = await Promise.all([
        userService.getAchievements(),
        userService.getUserAchievements(userId),
        userService.getJobs(),
        userService.getUserJobs(userId),
      ]);

      console.log('ğŸ“Š Fetched data:', {
        achievements: allAchievements.length,
        userAchievements: userAch.length,
        jobs: allJobs.length,
        userJobs: userJ.length,
      });

      setAchievements(allAchievements);
      setUserAchievements(userAch);
      setJobs(allJobs);
      setUserJobs(userJ);
    } catch (error) {
      console.error('Failed to fetch achievements/jobs:', error);
    }
  }, [user]);

  // åˆå›ãƒ­ãƒ¼ãƒ‰
  useEffect(() => {
    const loadData = async () => {
      console.log('ğŸš€ loadData called, isAuthenticated:', isAuthenticated, 'user:', user?.userId);
      
      if (isAuthenticated && user) {
        setIsLoading(true);
        console.log('ğŸ“¦ Starting to load data...');
        try {
          console.log('ğŸ“¦ Loading user data...');
          await refreshUserData();
          console.log('âœ… User data loaded');
          
          console.log('ğŸ“¦ Loading habits...');
          await refreshHabits();
          console.log('âœ… Habits loaded');
          
          console.log('ğŸ“¦ Loading achievements and jobs...');
          await refreshAchievementsAndJobs();
          console.log('âœ… Achievements and jobs loaded');
        } catch (error) {
          console.error('âŒ Failed to load initial data:', error);
        } finally {
          console.log('ğŸ Setting isLoading to false');
          setIsLoading(false);
        }
      } else {
        console.log('ğŸ‘¤ No user, clearing state');
        setUserData(null);
        setHabits([]);
        setHabitRecords(new Map());
        setAchievements([]);
        setUserAchievements([]);
        setJobs([]);
        setUserJobs([]);
        setIsLoading(false);
      }
    };
    
    loadData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isAuthenticated, user?.userId]);

  // ç¿’æ…£ã‚’ä½œæˆ
  const createHabit = async (habit: Partial<Habit>): Promise<Habit | null> => {
    if (!user) return null;

    const newHabit = await habitService.createHabit({
      ...habit,
      userId: user.userId,
    });

    if (newHabit) {
      setHabits(prev => [...prev, newHabit]);
    }

    return newHabit;
  };

  // ç¿’æ…£ã‚’æ›´æ–°
  const updateHabit = async (habitId: string, updates: Partial<Habit>): Promise<Habit | null> => {
    const updatedHabit = await habitService.updateHabit(habitId, updates);

    if (updatedHabit) {
      setHabits(prev => prev.map(h => h.habitId === habitId ? updatedHabit : h));
    }

    return updatedHabit;
  };

  // ç¿’æ…£ã‚’å‰Šé™¤
  const deleteHabit = async (habitId: string): Promise<boolean> => {
    const success = await habitService.deleteHabit(habitId);

    if (success) {
      setHabits(prev => prev.filter(h => h.habitId !== habitId));
      // è¨˜éŒ²ã‚‚å‰Šé™¤ï¼ˆè¡¨ç¤ºã‹ã‚‰é™¤å¤–ï¼‰
      setHabitRecords(prev => {
        const newMap = new Map(prev);
        newMap.delete(habitId);
        return newMap;
      });
    }

    return success;
  };

  // ç¿’æ…£ã‚’å®Œäº†
  const completeHabit = async (
    habitId: string,
    date?: string,
    note?: string
  ): Promise<HabitRecord | null> => {
    if (!user) return null;

    const completedDate = date ?? getTodayDate();
    const result = await habitService.recordCompletion(
      habitId,
      user.userId,
      completedDate,
      note
    );

    if (result.record) {
      setHabitRecords(prev => {
        const newMap = new Map(prev);
        const existing = newMap.get(habitId) ?? [];
        newMap.set(habitId, [...existing, result.record!]);
        return newMap;
      });

      // ç¿’æ…£ãƒªã‚¹ãƒˆã‚‚æ›´æ–°ï¼ˆã‚¹ãƒˆãƒªãƒ¼ã‚¯ãŒå¤‰ã‚ã‚‹ï¼‰
      await refreshHabits();

      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°ï¼ˆçµŒé¨“å€¤ãªã©ï¼‰
      await refreshUserData();

      // ã‚¢ãƒãƒ¼ãƒ–ãƒ¡ãƒ³ãƒˆãƒã‚§ãƒƒã‚¯
      if (userData && achievements.length > 0) {
        const updatedHabits = await habitService.getHabits(user.userId);
        const updatedUser = await userService.getUser(user.userId);
        
        if (updatedUser) {
          const checkResult = await achievementService.checkAchievements(
            updatedUser,
            updatedHabits,
            achievements,
            userAchievements
          );

          // æ–°ã—ãè§£é™¤ã•ã‚ŒãŸã‚¢ãƒãƒ¼ãƒ–ãƒ¡ãƒ³ãƒˆãŒã‚ã‚Œã°é€šçŸ¥
          if (checkResult.newlyUnlocked.length > 0) {
            for (const ach of checkResult.newlyUnlocked) {
              console.log(`ğŸ† ç§°å· ã‹ã„ã»ã†: ${ach.name} (+${ach.expReward} EXP)`);
            }
            // UserAchievementsã‚’å†å–å¾—
            const updatedUserAch = await userService.getUserAchievements(user.userId);
            setUserAchievements(updatedUserAch);
            // çµŒé¨“å€¤ã‚‚æ›´æ–°ã•ã‚ŒãŸã®ã§å†å–å¾—
            await refreshUserData();
          }
        }
      }

      // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—é€šçŸ¥ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
      if (result.levelUp) {
        console.log('ğŸ‰ Level Up!');
      }

      console.log(`âœ¨ +${result.expGained} EXP`);
    }

    return result.record;
  };

  // ç‰¹å®šã®æ—¥ã®è¨˜éŒ²ã‚’å–å¾—
  const getHabitRecordsForDate = (habitId: string, date: string): HabitRecord | undefined => {
    const records = habitRecords.get(habitId) ?? [];
    return records.find(r => r.completedDate === date && r.completed);
  };

  // ä»Šæ—¥å®Œäº†æ¸ˆã¿ã‹ã©ã†ã‹
  const isHabitCompletedToday = (habitId: string): boolean => {
    const today = getTodayDate();
    return !!getHabitRecordsForDate(habitId, today);
  };

  // è·æ¥­ã‚’é¸æŠï¼ˆè§£æ”¾æ¸ˆã¿ã®è·æ¥­ã®ã¿é¸æŠå¯èƒ½ï¼‰
  const selectJob = async (jobId: string): Promise<boolean> => {
    if (!user || !userData) return false;

    // beginnerï¼ˆã¿ãªã‚‰ã„ï¼‰ã¯å¸¸ã«é¸æŠå¯èƒ½
    const isUnlocked = jobId === 'beginner' || userJobs.some(uj => uj.jobId === jobId && uj.isUnlocked);
    if (!isUnlocked) {
      console.log('âŒ ã“ã®è·æ¥­ã¯ã¾ã è§£æ”¾ã•ã‚Œã¦ã„ã¾ã›ã‚“');
      return false;
    }

    try {
      const updatedUser = await userService.updateUser(user.userId, { currentJobId: jobId });
      if (updatedUser) {
        setUserData(updatedUser);
        const job = jobs.find(j => j.jobId === jobId);
        console.log(`âš”ï¸ è·æ¥­ã‚’ã€Œ${job?.name ?? jobId}ã€ã«å¤‰æ›´ã—ã¾ã—ãŸï¼`);
        return true;
      }
      return false;
    } catch (error) {
      console.error('Failed to select job:', error);
      return false;
    }
  };

  // æ€§åˆ¥ã‚’å¤‰æ›´
  const changeGender = async (gender: Gender): Promise<boolean> => {
    if (!user || !userData) return false;

    try {
      const updatedUser = await userService.updateUser(user.userId, { gender });
      console.log('ğŸ‘¤ changeGender - updatedUser:', updatedUser);
      console.log('ğŸ‘¤ changeGender - updatedUser.gender:', updatedUser?.gender);
      if (updatedUser) {
        // æ˜ç¤ºçš„ã«genderã‚’å«ã‚€æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
        const newUserData = { ...userData, ...updatedUser, gender };
        console.log('ğŸ‘¤ changeGender - newUserData:', newUserData);
        setUserData(newUserData);
        const genderLabel = gender === 'male' ? 'ç”·æ€§' : 'å¥³æ€§';
        console.log(`ğŸ‘¤ æ€§åˆ¥ã‚’ã€Œ${genderLabel}ã€ã«å¤‰æ›´ã—ã¾ã—ãŸï¼`);
        return true;
      }
      return false;
    } catch (error) {
      console.error('Failed to change gender:', error);
      return false;
    }
  };

  return (
    <UserContext.Provider
      value={{
        userData,
        habits,
        habitRecords,
        achievements,
        userAchievements,
        jobs,
        userJobs,
        isLoading,
        needsProfileSetup,
        refreshUserData,
        refreshHabits,
        createHabit,
        updateHabit,
        deleteHabit,
        completeHabit,
        getHabitRecordsForDate,
        isHabitCompletedToday,
        selectJob,
        changeGender,
      }}
    >
      {children}
    </UserContext.Provider>
  );
}

export function useUser() {
  const context = useContext(UserContext);
  if (context === undefined) {
    throw new Error('useUser must be used within a UserProvider');
  }
  return context;
}
