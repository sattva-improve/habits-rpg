/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
 * ãƒ­ã‚°ã‚¤ãƒ³ä¸­ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚²ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’ç®¡ç†
 */

import { createContext, useContext, useEffect, useState, ReactNode, useCallback, useRef } from 'react';
import { useAuth } from './AuthContext';
import { userService } from '../services/user';
import { habitService } from '../services/habit';
import { achievementService } from '../services/achievement';
import { seedService } from '../services/seed';
import { toast } from 'sonner';
import { playSoundGlobal } from '../hooks/useSound';
import type { User, Habit, HabitRecord, Achievement, UserAchievement, Job, UserJob, Gender } from '../types';

interface UserContextType {
  // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿
  userData: User | null;
  habits: Habit[];
  habitRecords: Map<string, HabitRecord[]>;
  achievements: Achievement[];
  userAchievements: UserAchievement[];
  jobs: Job[];
  userJobs: UserJob[];
  
  // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹
  isLoading: boolean;
  
  // ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«è¨­å®šãŒå¿…è¦ã‹ã©ã†ã‹
  needsProfileSetup: boolean;
  
  // ãƒ‡ãƒ¼ã‚¿æ“ä½œé–¢æ•°
  refreshUserData: () => Promise<void>;
  refreshHabits: () => Promise<void>;
  createHabit: (habit: Partial<Habit>) => Promise<Habit | null>;
  updateHabit: (habitId: string, updates: Partial<Habit>) => Promise<Habit | null>;
  deleteHabit: (habitId: string) => Promise<boolean>;
  completeHabit: (habitId: string, date?: string, note?: string) => Promise<HabitRecord | null>;
  getHabitRecordsForDate: (habitId: string, date: string) => HabitRecord | undefined;
  isHabitCompletedToday: (habitId: string) => boolean;
  // è·æ¥­é¸æŠ
  selectJob: (jobId: string) => Promise<boolean>;
  // æ€§åˆ¥å¤‰æ›´
  changeGender: (gender: Gender) => Promise<boolean>;
}

const UserContext = createContext<UserContextType | undefined>(undefined);

export function UserProvider({ children }: { children: ReactNode }) {
  const { user, isAuthenticated } = useAuth();
  
  const [userData, setUserData] = useState<User | null>(null);
  const [habits, setHabits] = useState<Habit[]>([]);
  const [habitRecords, setHabitRecords] = useState<Map<string, HabitRecord[]>>(new Map());
  const [achievements, setAchievements] = useState<Achievement[]>([]);
  const [userAchievements, setUserAchievements] = useState<UserAchievement[]>([]);
  const [jobs, setJobs] = useState<Job[]>([]);
  const [userJobs, setUserJobs] = useState<UserJob[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [needsProfileSetup, setNeedsProfileSetup] = useState(false);

  // ä»Šæ—¥ã®æ—¥ä»˜ã‚’YYYY-MM-DDå½¢å¼ã§å–å¾—ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã‚’è€ƒæ…®ï¼‰
  const getTodayDate = useCallback(() => {
    const timezone = userData?.timezone ?? 'Asia/Tokyo';
    try {
      const now = new Date();
      const formatter = new Intl.DateTimeFormat('sv-SE', {
        timeZone: timezone,
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
      });
      return formatter.format(now);
    } catch {
      // ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ãŒç„¡åŠ¹ãªå ´åˆã¯ãƒ­ãƒ¼ã‚«ãƒ«æ™‚åˆ»ã‚’ä½¿ç”¨
      return new Date().toISOString().split('T')[0];
    }
  }, [userData?.timezone]);

  // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã¾ãŸã¯ä½œæˆ
  const refreshUserData = useCallback(async () => {
    if (!user) {
      setUserData(null);
      setNeedsProfileSetup(false);
      return;
    }

    try {
      const userId = user.userId;
      const existingUser = await userService.getUser(userId);

      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå­˜åœ¨ã—ãªã„å ´åˆã€ã¾ãŸã¯displayNameãŒè‡ªå‹•ç”Ÿæˆã•ã‚ŒãŸã¾ã¾ã®å ´åˆã¯ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«è¨­å®šãŒå¿…è¦
      if (!existingUser) {
        setUserData(null);
        setNeedsProfileSetup(true);
        return;
      }

      // displayNameãŒãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã®@ã‚ˆã‚Šå‰ã®éƒ¨åˆ†ã¨åŒã˜å ´åˆã¯ã€è‡ªå‹•ç”Ÿæˆã•ã‚ŒãŸã¨ã¿ãªã—ã¦ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«è¨­å®šã‚’ä¿ƒã™
      // ãŸã ã—ã€SSOä»¥å¤–ã®é€šå¸¸ã‚µã‚¤ãƒ³ã‚¢ãƒƒãƒ—ã®å ´åˆã¯é™¤å¤–
      const email = existingUser.email || '';
      const defaultDisplayName = email.split('@')[0];
      const isAutoGenerated = existingUser.displayName === defaultDisplayName && 
                              !existingUser.displayName.includes(' ');
      
      // Google SSOã®å ´åˆã®ã¿ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«è¨­å®šã‚’ä¿ƒã™ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ˜ç¤ºçš„ã«displayNameã‚’è¨­å®šã—ã¦ã„ãªã„å ´åˆï¼‰
      // ãŸã ã—ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ—¢ã«ç¿’æ…£ã‚’ä½œæˆã—ã¦ã„ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
      setUserData(existingUser);
      setNeedsProfileSetup(false);
    } catch (error) {
      console.error('Failed to fetch/create user data:', error);
      setNeedsProfileSetup(false);
    }
  }, [user]);

  // ç¿’æ…£ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
  const refreshHabits = useCallback(async () => {
    if (!user) {
      setHabits([]);
      return;
    }

    try {
      const userId = user.userId;
      const userHabits = await habitService.getHabits(userId);
      setHabits(userHabits.filter(h => !h.isArchived && h.isActive));

      // å„ç¿’æ…£ã®è¨˜éŒ²ã‚’ä¸¦åˆ—ã§å–å¾—ï¼ˆå¤§å¹…ãªé«˜é€ŸåŒ–ï¼‰
      const recordPromises = userHabits.map(async habit => {
        const records = await habitService.getHabitRecords(habit.habitId);
        return { habitId: habit.habitId, records };
      });
      const results = await Promise.all(recordPromises);
      const recordsMap = new Map<string, HabitRecord[]>();
      for (const { habitId, records } of results) {
        recordsMap.set(habitId, records);
      }
      setHabitRecords(recordsMap);
    } catch (error) {
      console.error('Failed to fetch habits:', error);
    }
  }, [user]);

  // ã‚¢ãƒãƒ¼ãƒ–ãƒ¡ãƒ³ãƒˆã¨ã‚¸ãƒ§ãƒ–ã‚’å–å¾—
  const refreshAchievementsAndJobs = useCallback(async () => {
    if (!user) {
      setAchievements([]);
      setUserAchievements([]);
      setJobs([]);
      setUserJobs([]);
      return;
    }

    try {
      const userId = user.userId;
      
      // ã‚·ãƒ¼ãƒ‰æ¸ˆã¿ãƒã‚§ãƒƒã‚¯ï¼ˆLocalStorageãƒ•ãƒ©ã‚°ï¼‰
      const seedCompleted = seedService.isSeedCompleted();
      
      if (!seedCompleted) {
        // ã¾ãšãƒã‚¹ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿ã®å­˜åœ¨ã‚’ç´ æ—©ããƒã‚§ãƒƒã‚¯
        const { hasAchievements, hasJobs } = await seedService.checkMasterDataExists();
        
        if (!hasAchievements || !hasJobs) {
          await seedService.seedAll();
        }
        
        // ã‚·ãƒ¼ãƒ‰å®Œäº†ã‚’ãƒãƒ¼ã‚¯
        seedService.markSeedCompleted();
      }
      
      // ä¸¦è¡Œã—ã¦ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
      const [allAchievements, userAch, allJobs, userJ] = await Promise.all([
        userService.getAchievements(),
        userService.getUserAchievements(userId),
        userService.getJobs(),
        userService.getUserJobs(userId),
      ]);

      setAchievements(allAchievements);
      setUserAchievements(userAch);
      setJobs(allJobs);
      setUserJobs(userJ);
    } catch (error) {
      console.error('Failed to fetch achievements/jobs:', error);
    }
  }, [user]);

  // åˆå›ãƒ­ãƒ¼ãƒ‰ï¼ˆä¸¦åˆ—åŒ–ã§é«˜é€ŸåŒ–ï¼‰
  useEffect(() => {
    const loadData = async () => {
      if (isAuthenticated && user) {
        setIsLoading(true);
        try {
          // ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä¸¦åˆ—ã§å–å¾—ï¼ˆå¤§å¹…ãªé«˜é€ŸåŒ–ï¼‰
          await Promise.all([
            refreshUserData(),
            refreshHabits(),
            refreshAchievementsAndJobs(),
          ]);
        } catch (error) {
          console.error('âŒ Failed to load initial data:', error);
        } finally {
          setIsLoading(false);
        }
      } else {
        setUserData(null);
        setHabits([]);
        setHabitRecords(new Map());
        setAchievements([]);
        setUserAchievements([]);
        setJobs([]);
        setUserJobs([]);
        setIsLoading(false);
      }
    };
    
    loadData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isAuthenticated, user?.userId]);

  // ç¿’æ…£ã‚’ä½œæˆ
  const createHabit = async (habit: Partial<Habit>): Promise<Habit | null> => {
    if (!user) return null;

    const newHabit = await habitService.createHabit({
      ...habit,
      userId: user.userId,
    });

    if (newHabit) {
      setHabits(prev => [...prev, newHabit]);
    }

    return newHabit;
  };

  // ç¿’æ…£ã‚’æ›´æ–°
  const updateHabit = async (habitId: string, updates: Partial<Habit>): Promise<Habit | null> => {
    const updatedHabit = await habitService.updateHabit(habitId, updates);

    if (updatedHabit) {
      setHabits(prev => prev.map(h => h.habitId === habitId ? updatedHabit : h));
    }

    return updatedHabit;
  };

  // ç¿’æ…£ã‚’å‰Šé™¤
  const deleteHabit = async (habitId: string): Promise<boolean> => {
    const success = await habitService.deleteHabit(habitId);

    if (success) {
      setHabits(prev => prev.filter(h => h.habitId !== habitId));
      // è¨˜éŒ²ã‚‚å‰Šé™¤ï¼ˆè¡¨ç¤ºã‹ã‚‰é™¤å¤–ï¼‰
      setHabitRecords(prev => {
        const newMap = new Map(prev);
        newMap.delete(habitId);
        return newMap;
      });
    }

    return success;
  };

  // ç¿’æ…£ã‚’å®Œäº†
  const completeHabit = async (
    habitId: string,
    date?: string,
    note?: string
  ): Promise<HabitRecord | null> => {
    if (!user) return null;

    const completedDate = date ?? getTodayDate();
    const oldLevel = userData?.level ?? 1;
    
    const result = await habitService.recordCompletion(
      habitId,
      user.userId,
      completedDate,
      note
    );

    if (result.record) {
      // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒ†ãƒ¼ãƒˆã‚’å³åº§ã«æ›´æ–°ï¼ˆUIãƒ¬ã‚¹ãƒãƒ³ã‚¹å‘ä¸Šï¼‰
      setHabitRecords(prev => {
        const newMap = new Map(prev);
        const existing = newMap.get(habitId) ?? [];
        newMap.set(habitId, [...existing, result.record!]);
        return newMap;
      });

      // ç¿’æ…£ã®ã‚¹ãƒˆãƒªãƒ¼ã‚¯æ›´æ–°ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã§å³åº§ã«åæ˜ 
      // æ³¨: å®Ÿéš›ã®ã‚¹ãƒˆãƒªãƒ¼ã‚¯å€¤ã¯recordCompletionã§è¨ˆç®—ã•ã‚Œã‚‹ãŸã‚ã€
      // ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰æ›´æ–°ã§æ­£ç¢ºãªå€¤ã«æ›´æ–°ã•ã‚Œã‚‹
      setHabits(prev => prev.map(h => {
        if (h.habitId === habitId) {
          // ã‚¹ãƒˆãƒªãƒ¼ã‚¯å€¤ã¯result.record.streakAtCompletionã‹ã‚‰å–å¾—
          const newStreak = result.record!.streakAtCompletion;
          return {
            ...h,
            currentStreak: newStreak,
            bestStreak: Math.max(h.bestStreak, newStreak),
            totalCompletions: h.totalCompletions + 1,
          };
        }
        return h;
      }));

      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ã¨ç§°å·ãƒã‚§ãƒƒã‚¯ã‚’ä¸¦åˆ—ã§å®Ÿè¡Œï¼ˆãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰æ›´æ–°ï¼‰
      const updatePromise = (async () => {
        const [updatedUser, updatedHabits] = await Promise.all([
          userService.getUser(user.userId),
          habitService.getHabits(user.userId),
        ]);
        
        if (updatedUser) {
          setUserData(updatedUser);
          setHabits(updatedHabits.filter(h => !h.isArchived && h.isActive));
          
          // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—é€šçŸ¥
          if (updatedUser.level > oldLevel) {
            playSoundGlobal('levelUp');
            toast.success(`ğŸ‰ ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ï¼ Lv.${updatedUser.level} ã«ãªã‚Šã¾ã—ãŸï¼`, {
              duration: 4000,
              style: {
                background: 'linear-gradient(135deg, #1e293b 0%, #334155 100%)',
                border: '2px solid #fbbf24',
                color: '#fbbf24',
              },
            });
          }
          
          // ã‚¢ãƒãƒ¼ãƒ–ãƒ¡ãƒ³ãƒˆãƒã‚§ãƒƒã‚¯ï¼ˆç§°å·ç²å¾—ï¼‰
          if (achievements.length > 0) {
            const checkResult = await achievementService.checkAchievements(
              updatedUser,
              updatedHabits,
              achievements,
              userAchievements
            );

            // æ–°ã—ãè§£é™¤ã•ã‚ŒãŸã‚¢ãƒãƒ¼ãƒ–ãƒ¡ãƒ³ãƒˆãŒã‚ã‚Œã°é€šçŸ¥
            if (checkResult.newlyUnlocked.length > 0) {
              playSoundGlobal('achievement');
              for (const ach of checkResult.newlyUnlocked) {
                toast.success(`ğŸ† ç§°å·ã‹ã„ã»ã†ã€Œ${ach.name}ã€ï¼ +${ach.expReward} EXP`, {
                  duration: 5000,
                  style: {
                    background: 'linear-gradient(135deg, #1e293b 0%, #334155 100%)',
                    border: '2px solid #a855f7',
                    color: '#e9d5ff',
                  },
                });
              }
              // UserAchievementsã‚’å†å–å¾—
              const updatedUserAch = await userService.getUserAchievements(user.userId);
              setUserAchievements(updatedUserAch);
              // çµŒé¨“å€¤ã‚‚æ›´æ–°ã•ã‚ŒãŸã®ã§å†å–å¾—
              const finalUser = await userService.getUser(user.userId);
              if (finalUser) setUserData(finalUser);
            }
          }

          // ã‚¸ãƒ§ãƒ–è§£æ”¾ãƒã‚§ãƒƒã‚¯
          if (jobs.length > 0) {
            const jobCheckResult = await achievementService.checkJobs(
              updatedUser,
              jobs,
              userJobs,
              userAchievements
            );

            // æ–°ã—ãè§£æ”¾ã•ã‚ŒãŸã‚¸ãƒ§ãƒ–ãŒã‚ã‚Œã°é€šçŸ¥
            if (jobCheckResult.newlyUnlocked.length > 0) {
              playSoundGlobal('jobUnlock');
              for (const job of jobCheckResult.newlyUnlocked) {
                toast.success(`âš”ï¸ ã—ã‚‡ããã‚‡ã†ã€Œ${job.name}ã€ãŒã‹ã„ã»ã†ã•ã‚ŒãŸï¼`, {
                  duration: 5000,
                  style: {
                    background: 'linear-gradient(135deg, #1e293b 0%, #334155 100%)',
                    border: '2px solid #7c3aed',
                    color: '#c4b5fd',
                  },
                });
              }
              // UserJobsã‚’å†å–å¾—
              const updatedUserJobs = await userService.getUserJobs(user.userId);
              setUserJobs(updatedUserJobs);
            }
          }
        }
      })();

      // ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§æ›´æ–°ã‚’å¾…ã¤ï¼ˆUIã¯ãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„ï¼‰
      updatePromise.catch(err => console.error('Background update failed:', err));
    }

    return result.record;
  };

  // ç‰¹å®šã®æ—¥ã®è¨˜éŒ²ã‚’å–å¾—
  const getHabitRecordsForDate = (habitId: string, date: string): HabitRecord | undefined => {
    const records = habitRecords.get(habitId) ?? [];
    return records.find(r => r.completedDate === date && r.completed);
  };

  // ä»Šæ—¥å®Œäº†æ¸ˆã¿ã‹ã©ã†ã‹
  const isHabitCompletedToday = (habitId: string): boolean => {
    const today = getTodayDate();
    return !!getHabitRecordsForDate(habitId, today);
  };

  // è·æ¥­ã‚’é¸æŠï¼ˆè§£æ”¾æ¸ˆã¿ã®è·æ¥­ã®ã¿é¸æŠå¯èƒ½ï¼‰
  const selectJob = async (jobId: string): Promise<boolean> => {
    if (!user || !userData) return false;

    // beginnerï¼ˆã¿ãªã‚‰ã„ï¼‰ã¯å¸¸ã«é¸æŠå¯èƒ½
    const isUnlocked = jobId === 'beginner' || userJobs.some(uj => uj.jobId === jobId && uj.isUnlocked);
    if (!isUnlocked) {
      console.log('âŒ ã“ã®è·æ¥­ã¯ã¾ã è§£æ”¾ã•ã‚Œã¦ã„ã¾ã›ã‚“');
      return false;
    }

    try {
      const updatedUser = await userService.updateUser(user.userId, { currentJobId: jobId });
      console.log('âš”ï¸ selectJob - updatedUser:', updatedUser);
      console.log('âš”ï¸ selectJob - updatedUser.currentJobId:', updatedUser?.currentJobId);
      if (updatedUser) {
        // æ˜ç¤ºçš„ã«currentJobIdã‚’å«ã‚€æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
        const newUserData = { ...userData, ...updatedUser, currentJobId: jobId };
        console.log('âš”ï¸ selectJob - newUserData:', newUserData);
        setUserData(newUserData);
        const job = jobs.find(j => j.jobId === jobId);
        console.log(`âš”ï¸ è·æ¥­ã‚’ã€Œ${job?.name ?? jobId}ã€ã«å¤‰æ›´ã—ã¾ã—ãŸï¼`);
        return true;
      }
      return false;
    } catch (error) {
      console.error('Failed to select job:', error);
      return false;
    }
  };

  // æ€§åˆ¥ã‚’å¤‰æ›´
  const changeGender = async (gender: Gender): Promise<boolean> => {
    if (!user || !userData) return false;

    try {
      const updatedUser = await userService.updateUser(user.userId, { gender });
      console.log('ğŸ‘¤ changeGender - updatedUser:', updatedUser);
      console.log('ğŸ‘¤ changeGender - updatedUser.gender:', updatedUser?.gender);
      if (updatedUser) {
        // æ˜ç¤ºçš„ã«genderã‚’å«ã‚€æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
        const newUserData = { ...userData, ...updatedUser, gender };
        console.log('ğŸ‘¤ changeGender - newUserData:', newUserData);
        setUserData(newUserData);
        const genderLabel = gender === 'male' ? 'ç”·æ€§' : 'å¥³æ€§';
        console.log(`ğŸ‘¤ æ€§åˆ¥ã‚’ã€Œ${genderLabel}ã€ã«å¤‰æ›´ã—ã¾ã—ãŸï¼`);
        return true;
      }
      return false;
    } catch (error) {
      console.error('Failed to change gender:', error);
      return false;
    }
  };

  return (
    <UserContext.Provider
      value={{
        userData,
        habits,
        habitRecords,
        achievements,
        userAchievements,
        jobs,
        userJobs,
        isLoading,
        needsProfileSetup,
        refreshUserData,
        refreshHabits,
        createHabit,
        updateHabit,
        deleteHabit,
        completeHabit,
        getHabitRecordsForDate,
        isHabitCompletedToday,
        selectJob,
        changeGender,
      }}
    >
      {children}
    </UserContext.Provider>
  );
}

export function useUser() {
  const context = useContext(UserContext);
  if (context === undefined) {
    throw new Error('useUser must be used within a UserProvider');
  }
  return context;
}
